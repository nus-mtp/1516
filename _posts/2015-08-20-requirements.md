---
layout: post
title: On Software Requirements
tag: lecture
date: 2015-08-20 15:38:00
---

In this week's lecture, we will talk about gathering and documenting software requirements.  Here are the outlines:

### Introduction
* The user requirements specify what your end-product can do / what the customer wants
* Functional / non-functional requirements
* Many tools for requirement gathering:
    * brainstorming
    * user survey
    * observation
    * interviews
    * focus groups
    * prototyping
    * analyzing related software
* Use whatever tools suitable for your project

<!--more-->


### Why Good Requirements Important?
* Helps to define the goals of the project
* Helps to communicate among team members and with customers
* Serve as a contract (for CS3283, can change later)
* Helps to determine test cases and evaluation criteria
* Helps to plan projects (estimate time, prioritize features)
* Helps to reduce bugs
* Leads to better software design

### Properties of Good Requirements
* Adapted from [Scott Sehlhorst’s Top Ten Rules](http://tynerblain.com/blog/2006/05/25/writing-good-requirements-the-big-ten-rules/) 
   1. Correct -- of course
   1. Valuable — put in requirements that are of good values to the users; solve their problems; support their strategy, etc.
       * prioritize the requirements (must-have, good-to-have, only-if-time-permits, etc)
   2. Easy to read — write for people with diff background; use figures; scannable; cross-references, etc.
   3. Design free — focus on what, not how
   4. Attainable - don't put in things you can't attain
       * e.g., "analyze 100 video cameras in real-time"
   5. Complete - doesn't leave out anything, consider error cases, external systems 
   6. Consistent — don’t put in impossible requirements, use consistent terms
       * e.g., "device"/"phone"/"mobile" -- are they the same or not.  Establish a project glossary will help. 
       * e.g., "only administrator can edit X", else where, "any user can edit X"
   7. Unambiguous - cannot be interpreted differently by different people 
       * e.g., avoid "the user",
   8. Verifiable - can be verified within your means (finite, cost-effective way to verify)
       * e.g., avoid "easy to use", "should work most of the time" 
   9. Atomic — cannot say “half of this requirement is implemented”
       * e.g., "user can post text, URLs, or photos to their wall." 

### Sample Requirements 
* [CIO: Collaborative Internet Observatory](https://wiki.nus.edu.sg/display/CIO/Collaborative+Internet+Observatory)
* [SoCMAS: SoC Module Admin Systems](https://wiki.nus.edu.sg/display/IMMS/SoC+Module+Administration+System+Home)


### Dilbert on Requirements

* [Make you design my software](http://dilbert.com/strips/comic/2006-01-29/)
* [It doesn't meet my needs](http://dilbert.com/strips/comic/2003-03-21/)
* [Forming in my mind](http://dilbert.com/strips/comic/1994-09-22/)
* [Feature List](http://dilbert.com/strips/comic/2001-04-14/)
* [Doomed](http://dilbert.com/strips/comic/1997-05-09/)
    

